# Spring Boot: Autoconfiguración y Perfiles

---

## 1. Autoconfiguración en Spring Boot

En la aplicación generada automáticamente por **Spring Initializer**, simplemente hemos añadido la anotación `@SpringBootApplication`. Solo con eso, ya hemos activado gran parte de la magia de Spring. Veamos qué significa realmente.

### 1.1 Significado de `@SpringBootApplication`

La anotación `@SpringBootApplication` es equivalente a incluir tres anotaciones:  

- `@EnableAutoConfiguration`  
- `@ComponentScan`  
- `@Configuration`  

Estas tres anotaciones trabajan juntas para facilitar la configuración automática de nuestra aplicación.

---

### 1.2 Autoconfiguración con `@EnableAutoConfiguration`

Al habilitar la autoconfiguración, Spring Boot intenta **adivinar y configurar los beans que probablemente necesitemos**.  

**Ejemplo:**  

- Si tenemos la librería **HSQLDB** en el classpath y no configuramos manualmente ningún bean de conexión, Spring Boot creará automáticamente una base de datos en memoria.

La forma más habitual de incluir librerías en el classpath es mediante un **gestor de dependencias** como Maven o Gradle.

**Control del orden de configuración:**

- `@AutoconfigureBefore`  
- `@AutoconfigureAfter`  

O podemos personalizar creando nuestras propias clases de configuración, asegurándonos de incluirlas en el fichero `spring.factories`.

#### Configuración condicional

Spring Boot ofrece anotaciones condicionales según la existencia de clases, beans o propiedades:

- `@ConditionalOnClass` / `@ConditionalOnMissingClass`  
- `@ConditionalOnBean` / `@ConditionalOnMissingBean`  
- `@ConditionalOnProperty` / `@ConditionalOnMissingProperty`  

Existen más condicionales relacionados con el tipo de aplicación, recursos, ficheros o incluso expresiones.

---

### 1.3 Escaneo de componentes con `@ComponentScan`

Al usar `@ComponentScan`, Spring localiza elementos anotados como:  

- `@Component`  
- `@Service`  
- `@Repository`  
- `@Controller`  

Todos estos elementos se registran automáticamente como **Spring Beans**, dentro del paquete principal de la aplicación.

---

### 1.4 Configuración adicional con `@Configuration`

`@Configuration` permite:

- Registrar beans adicionales en el contexto de la aplicación.  
- Importar clases de configuración adicionales usando `@Import`.

La clase anotada como `@SpringBootApplication` actúa como **la raíz de configuración** de nuestra aplicación.

> Nota: Si necesitamos usar XML, podemos cargarlo con `@ImportResource`.

---

### 1.5 Conclusión

La autoconfiguración por defecto de Spring Boot es potente y nos permite empezar rápido. Pero si no nos sirve tal como está, **podemos personalizarla y sobreescribir propiedades** según nuestras necesidades.  

¡Viva la magia de Spring Boot!

---

## 2. Perfiles en Spring Boot

Los **perfiles** permiten cambiar rápidamente la configuración de la aplicación según el entorno: desarrollo, pruebas o producción.

---

### 2.1 Configuración de perfiles en `application.yaml`

Renombramos el fichero `application.properties` a `application.yaml`:

#### Configuración por defecto

Si no indicamos un perfil específico, definimos un puerto por defecto, por ejemplo:

```yaml
server:
  port: 8080

---

Configuración de perfiles específicos

Para cada perfil, agregamos un separador (---) y configuramos el perfil:

spring:
  config:
    activate:
      on-profile: "desarrollo"

server:
  port: 8081
---
spring:
  config:
    activate:
      on-profile: "pruebas"

server:
  port: 8082
---
spring:
  config:
    activate:
      on-profile: "produccion"

server:
  port: 9000


Nota: Los nombres de los perfiles pueden ser personalizados, aunque es recomendable usar nombres claros.

2.2 Ejecutar la aplicación con un perfil específico
Desde Eclipse

Desplegar Run > Run Configurations.

Duplicar la configuración existente para cada perfil.

Cambiar el nombre, por ejemplo:

ReunionesApplication (des)

ReunionesApplication (test)

ReunionesApplication (prod)

En Environment, añadir la variable:

Nombre: spring.profiles.active
Valor: desarrollo


Aplicar y ejecutar.

Repetir para otros perfiles (pruebas o produccion).

Esto permite levantar múltiples servidores en distintos puertos para pruebas.

Desde línea de comandos o argumentos de JVM
-Dspring.profiles.active=pruevas


Esto ejecutará la aplicación con el perfil definido en application.yaml.

2.3 Probar los distintos perfiles

Puerto por defecto (sin perfil activo): localhost:8080

Perfil desarrollo: localhost:8081

Perfil pruebas: localhost:8082

Perfil producción: localhost:9000

En este ejemplo solo se cambian los puertos, pero podrían configurarse otras propiedades según el perfil.

