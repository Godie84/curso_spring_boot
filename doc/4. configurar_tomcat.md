# Configuración del tomcat integrado

@Bean
@WebServlet, @WebFilter, @WebListener

Si seleccionas líneas de la transcripción en esta sección, irás a la marca de tiempo en el vídeo.

Para alegría de muchos, Spring Boot viene con un servidor de aplicaciones Tomcat integrado. Con la configuración por defecto, Spring Boot nos proporciona un servlet que responderá en la ruta raíz con unos parámetros bastante adecuados. Si a pesar de ello queremos añadir nuestros propios servlets, filtros o listeners, es muy fácil hacerlo. Basta con configurarlos como beans. Podemos poner la anotación bean a algún método de nuestras clases de configuración que proporcione estos objetos. Otra opción es anotar la propia clase con su anotación correspondiente, WebServlet, WebFilter o WebListener, para que el componente sea escaneado y considerado en el contexto de nuestro contenedor, por defecto, el servidor Tomcat que hemos mencionado. 

En el poco frecuente escenario en el que necesitáramos un ServletContext adicional, siempre podemos cargarlo utilizando la interfaz ServletContextInterface. Digo poco frecuente, porque suele usarse solo para los filtros de seguridad, y la verdad es que, ya metidos en Spring, mejor usamos Spring Security para estos menesteres.

Para configurar el servidor Tomcat integrado, lo más sencillo es usar las propiedades, como hemos visto antes, modificando la propiedad `server.port`. Pero hay muchas otras propiedades que podemos manipular: la dirección, el puerto, la ruta del contexto. Pero también podemos acceder a las características de la administración de sesión, como las cookies, los timeouts, que son los tiempos de espera, la persistencia de la sesión. Son muchas, así que mejor nos metemos en el código fuente de la clase `ServerProperties` y cotilleamos un poco. Podemos rebuscarla entre los hash, pero sinceramente voy a ir por la vía rápida. Voy a empezar a escribir «ServerProp» en cualquier clase Java; en la única que tenemos me vale. Control+espacio para que Eclipse autocomplete y Command+clic para meternos dentro. Y ahora a cotillear. 

A primera vista, puede parecer que no son muchas propiedades, pues llegamos a la línea 130 y empiezan ya los métodos, pero no te precipites, porque si seguimos bajando, sobre la 237, encontramos la clase `Servlet`, una clase interna, con, a su vez, tropecientas propiedades. Si la cerramos, la clase `Tomcat` y así hasta... Command, flecha para abajo, las 1850 líneas de código del fichero, al borde de requerir una refactorización, ¿eh? ¿Te he mencionado que tengo un par de cursos aquí en LinledIn Learning sobre refactorización de código? Ahí lo dejo. Explora todo lo que quieras las propiedades modificables. 

Vuelvo para arriba y vamos a ver otras cosillas interesantes, como que no todas las propiedades están definidas en la misma clase. Alrededor de la línea 100, empezamos a encontrar algunos atributos etiquetados con `@NestedConfigurationProperty`. Y si clicamos en su clase, por ejemplo, en `Compression` en la línea 114, se nos abre una clase independiente. ¿Y qué tiene? ¡Aún más propiedades! Venga, mañana, examen de todas las propiedades. No, no, no, es broma. No tiene ningún sentido memorizar todo esto. 

Bueno, a lo que iba, que no me he ido a la línea 114 por casualidad. Es la de la compresión, que se quiere personalizar con frecuencia. Para activarla, podemos darle el valor `true` a la propiedad `server.compression.enabled`, que es el nombre del atributo en la línea 31 de la clase `Compression`. Que no, que tampoco te tienes que saber esto, pero sí quería que vieras cómo se emparejan los nombres de las propiedades en el fichero de configuración con las clases y atributos que acabamos de ver. 

Si activamos la compresión, cualquier respuesta de más de 2 kB será comprimida, a no ser que modifiquemos otra propiedad. ¿Adivinas cuál? Exacto, la de la línea 38. Naturalmente, también podemos modificar la lista de tipos mime que queremos que se compriman. 

Quizá aún más frecuente es querer cambiar el contenedor HTTP por uno que soporte TLS, dadas las importantes mejoras en seguridad que implica, y que además suele ser requisito para poder conectar con otras herramientas, ya que hoy en día todo debe viajar encriptado por internet. Evidentemente, podemos modificarlo a través de las propiedades. Pero si ciframos cosas, necesitamos claves criptográficas y, por tanto, un almacén de claves y una contraseña para acceder a él que le debemos proporcionar a la aplicación vía propiedades o variables de entorno. Así que con cuidado dónde la ponemos. Y si la subimos al sistema de control de versiones, cualquiera con acceso al sistema de control de versiones tendrá acceso a la contraseña y, por tanto, tendrá acceso al almacén de claves y... No sigo. 

Me sigues, ¿no? Mejor usar un gestor de secretos, ¿verdad? La documentación oficial de Spring es muy buena y te ayudará mejor que yo a configurar todo según tus necesidades, así que no me enrollo más con esto de las propiedades.
